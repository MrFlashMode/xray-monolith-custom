diff --git a/src/Include/xrRender/RenderVisual.h b/src/Include/xrRender/RenderVisual.h
index 94bc87e..a31273a 100644
--- a/src/Include/xrRender/RenderVisual.h
+++ b/src/Include/xrRender/RenderVisual.h
@@ -25,6 +25,10 @@ public:
 	virtual shared_str	_BCL	getDebugName() = 0;
 #endif
 
+	//--DSR-- HeatVision_start
+	virtual void MarkAsHot(bool is_hot) {};
+	//--DSR-- HeatVision_end
+
 	virtual IKinematics* _BCL dcast_PKinematics() { return 0; }
 	virtual IKinematicsAnimated* dcast_PKinematicsAnimated() { return 0; }
 	virtual IParticleCustom* dcast_ParticleCustom() { return 0; }
diff --git a/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp b/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
index 5035624..a45d2cd 100644
--- a/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
+++ b/src/Layers/xrRender/Blender_Recorder_StandartBinding.cpp
@@ -258,9 +258,26 @@ class cl_eye_P : public R_constant_setup
 		RCache.set_c(C, V.x, V.y, V.z, 1);
 	}
 };
-
 static cl_eye_P binder_eye_P;
 
+// interpolated eye position (crookr scope parallax)
+// We can improve this by clamping the magnitude of the travel here instead of in-shader. 
+// it would fix the issue with the fog "sticking" when moving too far off center
+extern float scope_fog_interp;
+extern float scope_fog_travel;
+class cl_eye_PL : public R_constant_setup
+{
+	Fvector tV;
+	virtual void setup(R_constant* C)
+	{
+		Fvector& V = RDEVICE.vCameraPosition;
+		tV = tV.lerp(tV, V, scope_fog_interp);
+
+		RCache.set_c(C, tV.x, tV.y, tV.z, 1);
+	}
+};
+static cl_eye_PL binder_eye_PL;
+
 // eye-params
 class cl_eye_D : public R_constant_setup
 {
@@ -270,9 +287,22 @@ class cl_eye_D : public R_constant_setup
 		RCache.set_c(C, V.x, V.y, V.z, 0);
 	}
 };
-
 static cl_eye_D binder_eye_D;
 
+// interpolated eye direction (crookr scope parallax)
+class cl_eye_DL : public R_constant_setup
+{
+	Fvector tV;
+	virtual void setup(R_constant* C)
+	{
+		Fvector& V = RDEVICE.vCameraDirection;
+		tV = tV.lerp(tV, V, scope_fog_interp);
+
+		RCache.set_c(C, tV.x, tV.y, tV.z, 0);
+	}
+};
+static cl_eye_DL binder_eye_DL;
+
 // eye-params
 class cl_eye_N : public R_constant_setup
 {
@@ -285,6 +315,97 @@ class cl_eye_N : public R_constant_setup
 
 static cl_eye_N binder_eye_N;
 
+
+// fake scope params (crookr)
+extern float scope_outerblur;
+extern float scope_innerblur;
+extern float scope_scrollpower;
+extern float scope_brightness;
+class cl_fakescope_params : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_scrollpower, scope_innerblur, scope_outerblur, scope_brightness);
+	}
+};
+static cl_fakescope_params binder_fakescope_params;
+
+extern float scope_ca;
+extern float scope_fog_attack;
+extern float scope_fog_mattack;
+//extern float scope_fog_travel;
+class cl_fakescope_ca : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_ca, scope_fog_attack, scope_fog_mattack, scope_fog_travel);
+	}
+};
+static cl_fakescope_ca binder_fakescope_ca;
+
+extern float scope_radius;
+extern float scope_fog_radius;
+extern float scope_fog_sharp;
+//extern float scope_drift_amount;
+class cl_fakescope_params3 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, scope_radius, scope_fog_radius, scope_fog_sharp, 0.0f);
+	}
+};
+static cl_fakescope_params3 binder_fakescope_params3;
+
+//--DSR-- HeatVision_start
+extern float heat_vision_mode;
+extern Fvector4 heat_vision_steps;
+extern Fvector4 heat_vision_blurring;
+extern Fvector4 heat_vision_args_1;
+extern Fvector4 heat_vision_args_2;
+
+static class cl_heatvision_hotness : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.hemi.set_c_hotness(C);
+	}
+} binder_heatvision_hotness;
+
+static class cl_heatvision_steps : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, ps_r2_heatvision, heat_vision_steps.x, heat_vision_steps.y, heat_vision_steps.z);
+	}
+} binder_heatvision_params1;
+
+static class cl_heatvision_blurring : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, heat_vision_blurring.x, heat_vision_blurring.y, heat_vision_blurring.z, heat_vision_mode);
+	}
+} binder_heatvision_params2;
+
+static class cl_heatvision_args1 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, heat_vision_args_1.x, heat_vision_args_1.y, heat_vision_args_1.z, heat_vision_args_1.w);
+	}
+} binder_heatvision_args1;
+
+static class cl_heatvision_args2 : public R_constant_setup
+{
+	virtual void setup(R_constant* C)
+	{
+		RCache.set_c(C, heat_vision_args_2.x, heat_vision_args_2.y, heat_vision_args_2.z, heat_vision_args_2.w);
+	}
+} binder_heatvision_args2;
+
+//--DSR-- HeatVision_end
+
+
 #ifndef _EDITOR
 // D-Light0
 class cl_sun0_color : public R_constant_setup
@@ -639,7 +760,9 @@ void CBlender_Compile::SetMapping()
 
 	// eye-params
 	r_Constant("eye_position", &binder_eye_P);
+	r_Constant("eye_position_lerp", &binder_eye_PL); // crookr
 	r_Constant("eye_direction", &binder_eye_D);
+	r_Constant("eye_direction_lerp", &binder_eye_DL); // crookr
 	r_Constant("eye_normal", &binder_eye_N);
 
 #ifndef _EDITOR
@@ -690,10 +813,23 @@ void CBlender_Compile::SetMapping()
 	r_Constant("shader_param_7", &dev_param_7);
 	r_Constant("shader_param_8", &dev_param_8);
 
+	// crookr
+	r_Constant("fakescope_params1", &binder_fakescope_params);
+	r_Constant("fakescope_params2", &binder_fakescope_ca);
+	r_Constant("fakescope_params3", &binder_fakescope_params3);
+
 	// other common
 	for (u32 it = 0; it < DEV->v_constant_setup.size(); it++)
 	{
 		std::pair<shared_str, R_constant_setup*> cs = DEV->v_constant_setup[it];
 		r_Constant(*cs.first, cs.second);
 	}
+
+	//--DSR-- HeatVision_start
+	r_Constant("L_hotness", &binder_heatvision_hotness);
+	r_Constant("heatvision_params1", &binder_heatvision_params1);
+	r_Constant("heatvision_params2", &binder_heatvision_params2);
+	r_Constant("heatvision_params3", &binder_heatvision_args1);
+	r_Constant("heatvision_params4", &binder_heatvision_args2);
+	//--DSR-- HeatVision_end
 }
diff --git a/src/Layers/xrRender/FBasicVisual.cpp b/src/Layers/xrRender/FBasicVisual.cpp
index f8e4651..ba1455a 100644
--- a/src/Layers/xrRender/FBasicVisual.cpp
+++ b/src/Layers/xrRender/FBasicVisual.cpp
@@ -11,6 +11,7 @@
 
 #include "fbasicvisual.h"
 #include "../../xrEngine/fmesh.h"
+#include "dxRenderDeviceRender.h"
 
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
@@ -76,6 +77,21 @@ void dxRender_Visual::Load(const char* N, IReader* data, u32)
 #endif
 }
 
+//--DSR-- HeatVision_start
+void dxRender_Visual::MarkAsHot(bool is_hot) {
+	Shader* s = shader._get();
+	if (0 == s) return;
+	ShaderElement* e = s->E[0]._get();
+	if (0 == e || e->passes.empty()) return;
+	SPass* p = e->passes[0]._get();
+	STextureList* l = p->T._get();
+	if (0 == l || l->empty()) return;
+	CTexture* t = l->at(0).second._get();
+	if (t)
+		t->m_is_hot = is_hot;
+}
+//--DSR-- HeatVision_end
+
 #define PCOPY(a)	a = pFrom->a
 
 void dxRender_Visual::Copy(dxRender_Visual* pFrom)
diff --git a/src/Layers/xrRender/FBasicVisual.h b/src/Layers/xrRender/FBasicVisual.h
index 666dccc..aad4252 100644
--- a/src/Layers/xrRender/FBasicVisual.h
+++ b/src/Layers/xrRender/FBasicVisual.h
@@ -77,6 +77,10 @@ public:
 
 	virtual vis_data& _BCL getVisData() { return vis; }
 	virtual u32 getType() { return Type; }
+	
+	//--DSR-- HeatVision_start
+	virtual void MarkAsHot(bool is_hot);
+	//--DSR-- HeatVision_end
 
 	dxRender_Visual();
 	virtual ~dxRender_Visual();
diff --git a/src/Layers/xrRender/FHierrarhyVisual.cpp b/src/Layers/xrRender/FHierrarhyVisual.cpp
index c5b821a..68dacdc 100644
--- a/src/Layers/xrRender/FHierrarhyVisual.cpp
+++ b/src/Layers/xrRender/FHierrarhyVisual.cpp
@@ -90,6 +90,15 @@ void FHierrarhyVisual::Load(const char* N, IReader* data, u32 dwFlags)
 	}
 }
 
+//--DSR-- HeatVision_start
+void FHierrarhyVisual::MarkAsHot(bool is_hot) 
+{
+	dxRender_Visual::MarkAsHot(is_hot);
+	for (u32 i = 0; i < children.size(); i++)
+		children[i]->MarkAsHot(is_hot);
+}
+//--DSR-- HeatVision_end
+
 void FHierrarhyVisual::Copy(dxRender_Visual* pSrc)
 {
 	dxRender_Visual::Copy(pSrc);
diff --git a/src/Layers/xrRender/FHierrarhyVisual.h b/src/Layers/xrRender/FHierrarhyVisual.h
index 5f20c61..960ffe0 100644
--- a/src/Layers/xrRender/FHierrarhyVisual.h
+++ b/src/Layers/xrRender/FHierrarhyVisual.h
@@ -21,6 +21,10 @@ public:
 	virtual void Load(const char* N, IReader* data, u32 dwFlags);
 	virtual void Copy(dxRender_Visual* pFrom);
 	virtual void Release();
+
+	//--DSR-- HeatVision_start
+	virtual void MarkAsHot(bool is_hot);
+	//--DSR-- HeatVision_end
 };
 
 #endif //FHierrarhyVisualH
diff --git a/src/Layers/xrRender/R_Backend_hemi.cpp b/src/Layers/xrRender/R_Backend_hemi.cpp
index 15ccb1f..795f2f9 100644
--- a/src/Layers/xrRender/R_Backend_hemi.cpp
+++ b/src/Layers/xrRender/R_Backend_hemi.cpp
@@ -13,6 +13,9 @@ void R_hemi::unmap()
 	c_pos_faces = 0;
 	c_neg_faces = 0;
 	c_material = 0;
+	//--DSR-- HeatVision_start
+	c_hotness = 0;
+	//--DSR-- HeatVision_end
 }
 
 void R_hemi::set_pos_faces(float posx, float posy, float posz)
@@ -29,3 +32,10 @@ void R_hemi::set_material(float x, float y, float z, float w)
 {
 	if (c_material) RCache.set_c(c_material, x, y, z, w);
 }
+
+//--DSR-- HeatVision_start
+void R_hemi::set_hotness(float x, float y, float z, float w)
+{
+	if (c_hotness) RCache.set_c(c_hotness, x, y, z, w);
+}
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRender/R_Backend_hemi.h b/src/Layers/xrRender/R_Backend_hemi.h
index eaff851..911a71d 100644
--- a/src/Layers/xrRender/R_Backend_hemi.h
+++ b/src/Layers/xrRender/R_Backend_hemi.h
@@ -9,6 +9,10 @@ public:
 	R_constant* c_neg_faces;
 	R_constant* c_material;
 
+	//--DSR-- HeatVision_start
+	R_constant* c_hotness;
+	//--DSR-- HeatVision_end
+
 public:
 	R_hemi();
 	void unmap();
@@ -17,8 +21,17 @@ public:
 	void set_c_neg_faces(R_constant* C) { c_neg_faces = C; }
 	void set_c_material(R_constant* C) { c_material = C; }
 
+	//--DSR-- HeatVision_start
+	void set_c_hotness(R_constant* C) { c_hotness = C; }
+	//--DSR-- HeatVision_end
+
+
 	void set_pos_faces(float posx, float posy, float posz);
 	void set_neg_faces(float negx, float negy, float negz);
 	void set_material(float x, float y, float z, float w);
+
+	//--DSR-- HeatVision_start
+	void set_hotness(float x, float y, float z, float w);
+	//--DSR-- HeatVision_end
 };
 #endif
diff --git a/src/Layers/xrRender/SH_Texture.h b/src/Layers/xrRender/SH_Texture.h
index 62f91a6..cde2b8a 100644
--- a/src/Layers/xrRender/SH_Texture.h
+++ b/src/Layers/xrRender/SH_Texture.h
@@ -97,6 +97,10 @@ public: //	Public class members (must be encapsulated furthur)
 	float m_material;
 	shared_str m_bumpmap;
 
+	//--DSR-- HeatVision_start
+	bool m_is_hot = false;
+	//--DSR-- HeatVision_end
+
 	union
 	{
 		u32 m_play_time; // sync theora time
diff --git a/src/Layers/xrRender/rendertarget_phase_nightvision.cpp b/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
index 248d1c4..066b762 100644
--- a/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
+++ b/src/Layers/xrRender/rendertarget_phase_nightvision.cpp
@@ -51,3 +51,149 @@ void CRenderTarget::phase_nightvision()
 	HW.pContext->CopyResource(rt_Generic_0->pTexture->surface_get(), dest_rt->pTexture->surface_get());
 #endif
 };
+
+
+//crookr
+void CRenderTarget::phase_fakescope()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	Fvector2 p0, p1;
+#if defined(USE_DX10) || defined(USE_DX11)	
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f, 1.0f);
+#else
+	p0.set(0.5f / w, 0.5f / h);
+	p1.set((w + 0.5f) / w, (h + 0.5f) / h);
+#endif
+
+	//////////////////////////////////////////////////////////////////////////
+	//Set MSAA/NonMSAA rendertarget
+#if defined(USE_DX10) || defined(USE_DX11)
+	ref_rt& dest_rt = RImplementation.o.dx10_msaa ? rt_Generic : rt_Color;
+	u_setrt(dest_rt, nullptr, nullptr, nullptr);
+
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	//Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, float(h), d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(float(w), float(h), d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(float(w), 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_fakescope->E[ps_r2_nightvision]);
+
+	//Set geometry
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+	HW.pContext->CopyResource(rt_Generic_0->pTexture->surface_get(), dest_rt->pTexture->surface_get());
+#else
+	//Main pass (we avoid write-read from the same buffer)
+	u_setrt(rt_Generic_PingPong, nullptr, nullptr, nullptr);
+
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	//Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, float(h), d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(float(w), float(h), d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(float(w), 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_fakescope->E[0]);
+
+	//Set geometry
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+	//Draw to rt_Generic_0
+	u_setrt(rt_Generic_0, nullptr, nullptr, nullptr);
+
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	//Fill vertex buffer
+	pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, float(h), d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(float(w), float(h), d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(float(w), 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_fakescope->E[1]);
+
+	//Set geometry
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+#endif
+};
+
+//--DSR-- HeatVision_start
+void CRenderTarget::phase_heatvision()
+{
+	//Constants
+	u32 Offset = 0;
+	u32 C = color_rgba(0, 0, 0, 255);
+
+	float d_Z = EPS_S;
+	float d_W = 1.0f;
+	float w = float(Device.dwWidth);
+	float h = float(Device.dwHeight);
+
+	Fvector2 p0, p1;
+#if defined(USE_DX10) || defined(USE_DX11)	
+	p0.set(0.0f, 0.0f);
+	p1.set(1.0f, 1.0f);
+#else
+	p0.set(0.5f / w, 0.5f / h);
+	p1.set((w + 0.5f) / w, (h + 0.5f) / h);
+#endif
+
+	//////////////////////////////////////////////////////////////////////////
+	//Set MSAA/NonMSAA rendertarget
+#if defined(USE_DX10) || defined(USE_DX11)
+	ref_rt& dest_rt = RImplementation.o.dx10_msaa ? rt_Generic : rt_Color;
+	u_setrt(dest_rt, nullptr, nullptr, nullptr);
+#else
+	u_setrt(rt_Generic_0, nullptr, nullptr, nullptr);
+#endif		
+
+	RCache.set_CullMode(CULL_NONE);
+	RCache.set_Stencil(FALSE);
+
+	//Fill vertex buffer
+	FVF::TL* pv = (FVF::TL*)RCache.Vertex.Lock(4, g_combine->vb_stride, Offset);
+	pv->set(0, float(h), d_Z, d_W, C, p0.x, p1.y); pv++;
+	pv->set(0, 0, d_Z, d_W, C, p0.x, p0.y); pv++;
+	pv->set(float(w), float(h), d_Z, d_W, C, p1.x, p1.y); pv++;
+	pv->set(float(w), 0, d_Z, d_W, C, p1.x, p0.y); pv++;
+	RCache.Vertex.Unlock(4, g_combine->vb_stride);
+
+	//Set pass
+	RCache.set_Element(s_heatvision->E[ps_r2_heatvision]);
+
+	//Set geometry
+	RCache.set_Geometry(g_combine);
+	RCache.Render(D3DPT_TRIANGLELIST, Offset, 0, 4, 0, 2);
+
+#if defined(USE_DX10) || defined(USE_DX11)
+	HW.pContext->CopyResource(rt_Generic_0->pTexture->surface_get(), dest_rt->pTexture->surface_get());
+#endif
+};
+//--DSR-- HeatVision_start
diff --git a/src/Layers/xrRender/xrRender_console.cpp b/src/Layers/xrRender/xrRender_console.cpp
index 19cf561..b533250 100644
--- a/src/Layers/xrRender/xrRender_console.cpp
+++ b/src/Layers/xrRender/xrRender_console.cpp
@@ -258,6 +258,19 @@ Fvector ps_r2_drops_control = {.0f, 1.15f, .0f}; // r2-only
 
 int ps_r2_nightvision = 0;
 
+//--DSR-- HeatVision_start
+int ps_r2_heatvision = 0;
+float heat_vision_mode = 0.0f;
+Fvector4 heat_vision_steps = { 0.45f, 0.65f, 0.76f, .0f };
+Fvector4 heat_vision_blurring = { 15.f, 4.f, 60.f, .0f };
+Fvector4 heat_vision_args_1 = { .0f, .0f, .0f, .0f };
+Fvector4 heat_vision_args_2 = { .0f, .0f, .0f, .0f };
+//--DSR-- HeatVision_end
+
+//crookr
+int scope_fake_enabled = 1;
+//string32 scope_fake_texture = "wpn\\wpn_crosshair_pso1";
+
 float ps_r2_ss_sunshafts_length = 1.f;
 float ps_r2_ss_sunshafts_radius = 1.f;
 
@@ -1046,6 +1059,10 @@ void xrRender_initconsole()
 	CMD4(CCC_Vector4, "r__bloom_weight", &ps_pp_bloom_weight, twb_min, twb_max);
 	CMD4(CCC_Vector4, "r__bloom_thresh", &ps_pp_bloom_thresh, twb_min, twb_max);
 	CMD4(CCC_Integer, "r__nightvision", &ps_r2_nightvision, 0, 3); //For beef's nightvision shader or other stuff
+
+	CMD4(CCC_Integer, "r__fakescope", &scope_fake_enabled, 0, 1); //crookr for fake scope
+
+	CMD4(CCC_Integer, "r__heatvision", &ps_r2_heatvision, 0, 1); //--DSR-- HeatVision
 	CMD3(CCC_Mask, "r2_terrain_z_prepass", &ps_r2_ls_flags, R2FLAG_TERRAIN_PREPASS); //Terrain Z Prepass @Zagolski
 	
 	//////////other
@@ -1071,6 +1088,14 @@ void xrRender_initconsole()
 	CMD4(CCC_Vector4, "shader_param_7", &ps_dev_param_7, tw2_min, tw2_max);
 	CMD4(CCC_Vector4, "shader_param_8", &ps_dev_param_8, tw2_min, tw2_max);
 
+	//--DSR-- HeatVision_start
+	CMD2(CCC_Float,   "heat_vision_mode",		&heat_vision_mode);
+	CMD4(CCC_Vector4, "heat_vision_steps",		&heat_vision_steps, tw2_min, tw2_max);
+	CMD4(CCC_Vector4, "heat_vision_blurring",	&heat_vision_blurring, tw2_min, tw2_max);
+	CMD4(CCC_Vector4, "heat_vision_args_1",		&heat_vision_args_1, tw2_min, tw2_max);
+	CMD4(CCC_Vector4, "heat_vision_args_2",		&heat_vision_args_2, tw2_min, tw2_max);
+	//--DSR-- HeatVision_end
+
 	// Geometry optimization
 	CMD4(CCC_Integer, "r__optimize_static_geom", &opt_static, 0, 4);
 	CMD4(CCC_Integer, "r__optimize_dynamic_geom", &opt_dynamic, 0, 4);
diff --git a/src/Layers/xrRender/xrRender_console.h b/src/Layers/xrRender/xrRender_console.h
index 7ee8c11..80124c5 100644
--- a/src/Layers/xrRender/xrRender_console.h
+++ b/src/Layers/xrRender/xrRender_console.h
@@ -140,6 +140,8 @@ extern ECORE_API int ps_r2_qsync;
 extern ECORE_API Fvector4 ps_r2_mask_control; // r2-only
 extern ECORE_API Fvector ps_r2_drops_control; // r2-only
 extern ECORE_API int ps_r2_nightvision;
+extern ECORE_API int scope_fake_enabled; //crookr
+extern ECORE_API int ps_r2_heatvision; //--DSR-- HeatVision
 extern ECORE_API float ps_r2_ss_sunshafts_length;
 extern ECORE_API float ps_r2_ss_sunshafts_radius;
 extern u32 ps_sunshafts_mode;
diff --git a/src/Layers/xrRenderPC_R2/blender_nightvision.cpp b/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
index b44403b..29d2a42 100644
--- a/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R2/blender_nightvision.cpp
@@ -3,11 +3,21 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
+CBlender_heatvision::CBlender_heatvision() { description.CLS = 0;  } //--DSR-- HeatVision
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
 
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
+
+CBlender_heatvision::~CBlender_heatvision() //--DSR-- HeatVision_start
+{
+}
+
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
 	IBlender::Compile(C);
@@ -38,3 +48,37 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;	
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+	switch (C.iElement)
+	{
+	case 0: //Main pass
+		C.r_Pass("null", "fakescope", FALSE, FALSE, FALSE);
+		C.r_Sampler_rtf("s_position", r2_RT_P);
+		C.r_Sampler_clf("s_image", r2_RT_generic0);
+		C.r_Sampler_clf("s_blur_2", r2_RT_blur_2);
+		C.r_Sampler_clf("s_blur_4", r2_RT_blur_4);
+		C.r_Sampler_clf("s_blur_8", r2_RT_blur_8);
+		C.r_Sampler_clf("s_scope", r2_RT_scopert);
+		C.r_End();
+		break;
+	case 1: //Copy to rt_Generic_2
+		C.r_Pass("null", "copy", FALSE, FALSE, FALSE);	
+		C.r_Sampler_clf("s_base", "$user$generic_pingpong");	
+		C.r_End();
+		break;
+	}
+}
+
+//--DSR-- HeatVision_start
+void CBlender_heatvision::Compile(CBlender_Compile& C)
+{
+	IBlender::Compile(C);
+	C.r_Pass("null", "heatvision", FALSE, FALSE, FALSE);
+	C.r_Sampler_rtf("s_position", r2_RT_P);
+	C.r_Sampler_clf("s_image", r2_RT_generic0);
+	C.r_End();	
+}
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R2/blender_nightvision.h b/src/Layers/xrRenderPC_R2/blender_nightvision.h
index 0801e41..8efe46d 100644
--- a/src/Layers/xrRenderPC_R2/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R2/blender_nightvision.h
@@ -13,3 +13,32 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
+
+//--DSR-- HeatVision_start
+class CBlender_heatvision : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "heatvision"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_heatvision();
+	virtual ~CBlender_heatvision();
+};
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp b/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
index f55c506..39615de 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget.cpp
@@ -247,6 +247,8 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
+	b_heatvision = xr_new<CBlender_heatvision>(); //--DSR-- HeatVision
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -288,6 +290,11 @@ CRenderTarget::CRenderTarget()
 		rt_secondVP.create(r2_RT_secondVP, w, h, D3DFMT_A8R8G8B8); //--#SM+#-- +SecondVP+
 		rt_ui_pda.create(r2_RT_ui, w, h, D3DFMT_A8R8G8B8);
 
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
+		
+		//--DSR-- HeatVision_start
+		rt_Heat.create(r2_RT_heat, w, h, D3DFMT_A8R8G8B8, 1);
+		//--DSR-- HeatVision_end
 
 		// RT Blur
 		rt_blur_h_2.create(r2_RT_blur_h_2, u32(w/2), u32(h/2), D3DFMT_A8R8G8B8);
@@ -312,6 +319,8 @@ CRenderTarget::CRenderTarget()
 		//	temp: for higher quality blends
 		if (RImplementation.o.advancedpp)
 			rt_Generic_2.create(r2_RT_generic2, w, h, D3DFMT_A16B16G16R16F);
+
+		rt_Generic_PingPong.create("$user$generic_pingpong", w, h, D3DFMT_A8R8G8B8);
 	}
 
 	s_sunshafts.create(b_sunshafts, "r2\\sunshafts");
@@ -323,6 +332,8 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
+	s_heatvision.create(b_heatvision, "r2\\heatvision"); //--DSR-- HeatVision
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -758,6 +769,8 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
+	xr_delete(b_heatvision); //--DSR-- HeatVision
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget.h b/src/Layers/xrRenderPC_R2/r2_rendertarget.h
index 727029d..a4a3b86 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget.h
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget.h
@@ -39,6 +39,8 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
+	IBlender* b_heatvision; //--DSR-- HeatVision
 	IBlender* b_lut;
 	
 	IBlender* b_smaa;	
@@ -68,7 +70,11 @@ public:
 	ref_rt rt_secondVP;		// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 	ref_rt rt_ui_pda;
 
+	ref_rt rt_fakescope; //crookr
+	ref_rt rt_Generic_PingPong;
+
 	ref_rt rt_dof;
+	ref_rt rt_Heat; //--DSR-- HeatVision
 	
 	ref_rt rt_blur_h_2;
 	ref_rt rt_blur_2;
@@ -122,6 +128,8 @@ private:
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
 	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
+	ref_shader s_heatvision; //--DSR-- HeatVision
 
 	ref_shader s_blur;	
 	ref_shader s_dof;
@@ -260,6 +268,8 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
+	void phase_heatvision(); //--DSR-- HeatVision
 	void phase_lut();	
 	void phase_smaa();
 		
diff --git a/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
index bbec49c..443c2c0 100644
--- a/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R2/r2_rendertarget_phase_combine.cpp
@@ -276,6 +276,11 @@ void CRenderTarget::phase_combine()
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
 	
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
+
     //SMAA
 	if (ps_smaa_quality)
 	{
diff --git a/src/Layers/xrRenderPC_R2/r2_types.h b/src/Layers/xrRenderPC_R2/r2_types.h
index 7033e17..3d3c50d 100644
--- a/src/Layers/xrRenderPC_R2/r2_types.h
+++ b/src/Layers/xrRenderPC_R2/r2_types.h
@@ -62,6 +62,9 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+#define		r2_RT_heat			"$user$heat" //--DSR-- HeatVision
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R3/blender_nightvision.cpp b/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
index 1a5d5c6..6cecd9f 100644
--- a/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R3/blender_nightvision.cpp
@@ -3,11 +3,22 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
+CBlender_heatvision::CBlender_heatvision() { description.CLS = 0; } //--DSR-- HeatVision
+
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
 
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
+
+CBlender_heatvision::~CBlender_heatvision() //--DSR-- HeatVision
+{
+}
+
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
 	IBlender::Compile(C);
@@ -66,3 +77,44 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;		
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+
+	C.r_Pass("stub_screen_space", "fakescope", FALSE, FALSE, FALSE);
+	C.r_dx10Texture("s_position", r2_RT_P);
+	C.r_dx10Texture("s_image", r2_RT_generic0);
+	C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+	C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+	C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+	C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+
+	C.r_dx10Sampler("smp_base");
+	C.r_dx10Sampler("smp_nofilter");
+	C.r_dx10Sampler("smp_rtlinear");
+	C.r_End();
+
+}
+
+//--DSR-- HeatVision_start
+void CBlender_heatvision::Compile(CBlender_Compile& C)
+{
+	IBlender::Compile(C);
+	
+	C.r_Pass("stub_screen_space", "heatvision", FALSE, FALSE, FALSE);
+	C.r_dx10Texture("s_position", r2_RT_P);
+	C.r_dx10Texture("s_image", r2_RT_generic0);
+	C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+	C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+	C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+	C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+
+	C.r_dx10Texture("s_heat", r2_RT_heat);
+
+	C.r_dx10Sampler("smp_base");
+	C.r_dx10Sampler("smp_nofilter");
+	C.r_dx10Sampler("smp_rtlinear");
+	C.r_End();
+}
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R3/blender_nightvision.h b/src/Layers/xrRenderPC_R3/blender_nightvision.h
index 0801e41..8efe46d 100644
--- a/src/Layers/xrRenderPC_R3/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R3/blender_nightvision.h
@@ -13,3 +13,32 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
+
+//--DSR-- HeatVision_start
+class CBlender_heatvision : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "heatvision"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_heatvision();
+	virtual ~CBlender_heatvision();
+};
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R3/r2_types.h b/src/Layers/xrRenderPC_R3/r2_types.h
index 6597231..0414f9c 100644
--- a/src/Layers/xrRenderPC_R3/r2_types.h
+++ b/src/Layers/xrRenderPC_R3/r2_types.h
@@ -70,6 +70,9 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+#define		r2_RT_heat			"$user$heat" //--DSR-- HeatVision
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R3/r3.h b/src/Layers/xrRenderPC_R3/r3.h
index 3f8201b..d97e956 100644
--- a/src/Layers/xrRenderPC_R3/r3.h
+++ b/src/Layers/xrRenderPC_R3/r3.h
@@ -232,6 +232,11 @@ public:
 		o_hemi = 0.75f * LT.get_hemi();
 		//o_hemi						= 0.5f*LT.get_hemi			()	;
 		o_sun = 0.75f * LT.get_sun();
+
+		//--DSR-- Heatvision start
+		RCache.hemi.set_hotness(O->GetHotness(), O->GetTransparency(), 0.f, 0.f);
+		//--DSR-- Heatvision end
+
 		CopyMemory(o_hemi_cube, LT.get_hemi_cube(), CROS_impl::NUM_FACES*sizeof(float));
 	}
 
@@ -247,6 +252,9 @@ public:
 #ifdef	DEBUG
         if (ps_r2_ls_flags.test(R2FLAG_GLOBALMATERIAL))	mtl=ps_r2_gmaterial;
 #endif
+		if (!(T && T->m_is_hot))
+			RCache.hemi.set_hotness(0.f, 0.f, 0.f, 0.f);
+
 		RCache.hemi.set_material(o_hemi, o_sun, 0, (mtl < 5 ? (mtl + .5f) / 4.f : mtl));
 		RCache.hemi.set_pos_faces(o_hemi_cube[CROS_impl::CUBE_FACE_POS_X],
 		                          o_hemi_cube[CROS_impl::CUBE_FACE_POS_Y],
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp b/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
index 9c5ecf2..229f82d 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget.cpp
@@ -351,6 +351,8 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
+	b_heatvision = xr_new<CBlender_heatvision>(); //--DSR-- HeatVision
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -430,6 +432,12 @@ CRenderTarget::CRenderTarget()
 		rt_Generic_1.create(r2_RT_generic1, w, h, D3DFMT_A8R8G8B8, 1);
 		rt_Generic.create(r2_RT_generic, w, h, D3DFMT_A8R8G8B8, 1);
 
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
+
+		//--DSR-- HeatVision_start
+		rt_Heat.create(r2_RT_heat, w, h, D3DFMT_A8R8G8B8, SampleCount);
+		//--DSR-- HeatVision_end
+
         if (RImplementation.o.dx10_msaa)
             rt_Generic_temp.create("$user$generic_temp", w, h, D3DFMT_A8R8G8B8, SampleCount);
         else
@@ -477,6 +485,8 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
+	s_heatvision.create(b_heatvision, "r2\\heatvision"); //--DSR-- HeatVision
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -1143,6 +1153,8 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
+	xr_delete(b_heatvision); //--DSR-- HeatVision
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget.h b/src/Layers/xrRenderPC_R3/r3_rendertarget.h
index 6d332ba..b3cbb66 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget.h
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget.h
@@ -58,6 +58,8 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
+	IBlender* b_heatvision; //--DSR-- HeatVision
 	IBlender* b_lut;
 	
 	IBlender* b_smaa;	
@@ -93,6 +95,11 @@ public:
 	ref_rt rt_secondVP;		// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 	ref_rt rt_ui_pda;
 
+
+	ref_rt rt_fakescope; //crookr
+	
+	ref_rt rt_Heat; //--DSR-- HeatVision
+
 	ref_rt rt_dof;
 
 	ref_rt rt_blur_h_2;
@@ -171,6 +178,8 @@ private:
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
 	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
+	ref_shader s_heatvision; //--DSR-- HeatVision
 	ref_shader s_lut;	
 
     ref_shader s_smaa;
@@ -298,6 +307,8 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
+	void phase_heatvision(); //--DSR-- HeatVision
 	void phase_lut();	
 	void phase_smaa();	
 
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
index fe27772..face4ea 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_combine.cpp
@@ -291,10 +291,14 @@ void CRenderTarget::phase_combine()
 	// Forward rendering
 	{
 		PIX_EVENT(Forward_rendering);
+
+		//--DSR-- HeatVision_start
 		if (!RImplementation.o.dx10_msaa)
-			u_setrt(rt_Generic_0, 0, 0, HW.pBaseZB); // LDR RT
+			u_setrt(rt_Generic_0, rt_Heat, 0, HW.pBaseZB); // LDR RT
 		else
-			u_setrt(rt_Generic_0_r, 0, 0, RImplementation.Target->rt_MSAADepth->pZRT); // LDR RT
+			u_setrt(rt_Generic_0_r, rt_Heat, 0, RImplementation.Target->rt_MSAADepth->pZRT); // LDR RT
+		//--DSR-- HeatVision_end
+
 		RCache.set_CullMode(CULL_CCW);
 		RCache.set_Stencil(FALSE);
 		RCache.set_ColorWriteEnable();
@@ -396,6 +400,16 @@ void CRenderTarget::phase_combine()
 	
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
+
+	//--DSR-- HeatVision_start
+	if (ps_r2_heatvision > 0)
+		phase_heatvision();
+	//--DSR-- HeatVision_end
+
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
 	
     //SMAA
 	if (ps_smaa_quality)
diff --git a/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_scene.cpp b/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_scene.cpp
index a6dfbf8..86d27d8 100644
--- a/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_scene.cpp
+++ b/src/Layers/xrRenderPC_R3/r3_rendertarget_phase_scene.cpp
@@ -14,6 +14,10 @@ void CRenderTarget::phase_scene_prepare()
 		FLOAT ColorRGBA[4] = {0.0f, 0.0f, 0.0f, 0.0f};
 		HW.pDevice->ClearRenderTargetView(rt_Position->pRT, ColorRGBA);
 
+		//--DSR-- HeatVision_start
+		HW.pDevice->ClearRenderTargetView(rt_Heat->pRT, ColorRGBA);
+		//--DSR-- HeatVision_end
+
 		if (!RImplementation.o.dx10_msaa)
 			HW.pDevice->ClearDepthStencilView(HW.pBaseZB, D3D10_CLEAR_DEPTH | D3D10_CLEAR_STENCIL, 1.0f, 0);
 		else
@@ -39,8 +43,10 @@ void CRenderTarget::phase_scene_begin()
 
 	// Targets, use accumulator for temporary storage
 	{
-		if (RImplementation.o.albedo_wo) u_setrt(rt_Position, rt_Accumulator, pZB);
-		else u_setrt(rt_Position, rt_Color, pZB);
+		//--DSR-- HeatVision_start
+		if (RImplementation.o.albedo_wo) u_setrt(rt_Position, rt_Accumulator, rt_Heat, pZB);
+		else u_setrt(rt_Position, rt_Color, rt_Heat, pZB);
+		//--DSR-- HeatVision_end
 	}
 
 
diff --git a/src/Layers/xrRenderPC_R4/blender_nightvision.cpp b/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
index 1a5d5c6..a88a9a5 100644
--- a/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
+++ b/src/Layers/xrRenderPC_R4/blender_nightvision.cpp
@@ -3,11 +3,23 @@
 #include "blender_nightvision.h"
 
 CBlender_nightvision::CBlender_nightvision() { description.CLS = 0; }
+CBlender_fakescope::CBlender_fakescope() { description.CLS = 0; } //crookr
+CBlender_heatvision::CBlender_heatvision() { description.CLS = 0;  } //--DSR-- Heatvision
 
 CBlender_nightvision::~CBlender_nightvision()
 {
 }
 
+CBlender_fakescope::~CBlender_fakescope() //crookr
+{
+}
+
+//--DSR-- HeatVision_start
+CBlender_heatvision::~CBlender_heatvision()
+{
+}
+//--DSR-- HeatVision_end
+
 void CBlender_nightvision::Compile(CBlender_Compile& C)
 {
 	IBlender::Compile(C);
@@ -30,6 +42,9 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);		
+
+		C.r_dx10Texture("s_heat", r2_RT_heat); //--DSR-- HeatVision
+
 			
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_nofilter");
@@ -45,6 +60,8 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);		
 		
+		C.r_dx10Texture("s_heat", r2_RT_heat); //--DSR-- HeatVision
+
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
@@ -59,6 +76,8 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
 		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);		
 		
+		C.r_dx10Texture("s_heat", r2_RT_heat); //--DSR-- HeatVision
+
 		C.r_dx10Sampler("smp_base");
 		C.r_dx10Sampler("smp_nofilter");
 		C.r_dx10Sampler("smp_rtlinear");
@@ -66,3 +85,63 @@ void CBlender_nightvision::Compile(CBlender_Compile& C)
 		break;		
 	}
 }
+
+void CBlender_fakescope::Compile(CBlender_Compile& C) //crookr
+{
+	IBlender::Compile(C);
+
+	C.r_Pass("stub_screen_space", "fakescope", FALSE, FALSE, FALSE);
+	C.r_dx10Texture("s_position", r2_RT_P);
+	C.r_dx10Texture("s_image", r2_RT_generic0);
+	C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+	C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+	C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+	C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+	//C.r_dx10Texture("s_scope", "wpn\\wpn_crosshair_pso1");
+	//C.r_dx10Texture("s_scope", scope_fake_texture);
+	C.r_dx10Texture("s_scope", r2_RT_scopert);
+
+
+	C.r_dx10Sampler("smp_base");
+	C.r_dx10Sampler("smp_nofilter");
+	C.r_dx10Sampler("smp_rtlinear");
+	C.r_End();
+
+}
+
+//--DSR-- HeatVision_start
+void CBlender_heatvision::Compile(CBlender_Compile& C) 
+{
+	IBlender::Compile(C);
+
+	switch (C.iElement)
+	{
+	case 0: //Dummy shader - because IDK what gonna happen when r2_nightvision will be 0
+		C.r_Pass("stub_screen_space", "copy_nomsaa", FALSE, FALSE, FALSE);
+		C.r_dx10Texture("s_generic", r2_RT_generic0);
+
+		C.r_dx10Sampler("smp_base");
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_rtlinear");
+		C.r_End();
+		break;
+	case 1:
+		C.r_Pass("stub_screen_space", "heatvision", FALSE, FALSE, FALSE);
+		C.r_dx10Texture("s_position", r2_RT_P);
+		C.r_dx10Texture("s_image", r2_RT_generic0);
+		C.r_dx10Texture("s_bloom_new", r2_RT_pp_bloom);
+		C.r_dx10Texture("s_blur_2", r2_RT_blur_2);
+		C.r_dx10Texture("s_blur_4", r2_RT_blur_4);
+		C.r_dx10Texture("s_blur_8", r2_RT_blur_8);
+
+		C.r_dx10Texture("s_heat", r2_RT_heat); //--DSR-- HeatVision
+
+
+		C.r_dx10Sampler("smp_base");
+		C.r_dx10Sampler("smp_nofilter");
+		C.r_dx10Sampler("smp_rtlinear");
+		C.r_End();
+		break;
+	}
+}
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R4/blender_nightvision.h b/src/Layers/xrRenderPC_R4/blender_nightvision.h
index 0801e41..8efe46d 100644
--- a/src/Layers/xrRenderPC_R4/blender_nightvision.h
+++ b/src/Layers/xrRenderPC_R4/blender_nightvision.h
@@ -13,3 +13,32 @@ public:
 	CBlender_nightvision();
 	virtual ~CBlender_nightvision();
 };
+
+//crookr
+class CBlender_fakescope : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "fakescope"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_fakescope();
+	virtual ~CBlender_fakescope();
+};
+
+//--DSR-- HeatVision_start
+class CBlender_heatvision : public IBlender
+{
+public:
+	virtual LPCSTR getComment() { return "heatvision"; }
+	virtual BOOL canBeDetailed() { return FALSE; }
+	virtual BOOL canBeLMAPped() { return FALSE; }
+
+	virtual void Compile(CBlender_Compile& C);
+
+	CBlender_heatvision();
+	virtual ~CBlender_heatvision();
+};
+//--DSR-- HeatVision_end
diff --git a/src/Layers/xrRenderPC_R4/r2_types.h b/src/Layers/xrRenderPC_R4/r2_types.h
index 18a11d4..723d606 100644
--- a/src/Layers/xrRenderPC_R4/r2_types.h
+++ b/src/Layers/xrRenderPC_R4/r2_types.h
@@ -69,6 +69,9 @@
 #define		r2_RT_dof			"$user$dof"
 #define		r2_RT_ui			"$user$ui"
 
+#define		r2_RT_scopert		"$user$scopeRT" //crookr
+#define		r2_RT_heat			"$user$heat" //--DSR-- HeatVision
+
 #define		r2_RT_smaa_edgetex "$user$smaa_edgetex"
 #define		r2_RT_smaa_blendtex "$user$smaa_blendtex"
 
diff --git a/src/Layers/xrRenderPC_R4/r4.h b/src/Layers/xrRenderPC_R4/r4.h
index 9ae8b61..206708b 100644
--- a/src/Layers/xrRenderPC_R4/r4.h
+++ b/src/Layers/xrRenderPC_R4/r4.h
@@ -233,6 +233,9 @@ public:
 		o_hemi = 0.75f * LT.get_hemi();
 		//o_hemi						= 0.5f*LT.get_hemi			()	;
 		o_sun = 0.75f * LT.get_sun();
+		//--DSR-- HeatVision_start
+		RCache.hemi.set_hotness(O->GetHotness(), O->GetTransparency(), 0.f, 0.f);
+		//--DSR-- HeatVision_end
 		CopyMemory(o_hemi_cube, LT.get_hemi_cube(), CROS_impl::NUM_FACES*sizeof(float));
 	}
 
@@ -248,6 +251,9 @@ public:
 #ifdef	DEBUG
         if (ps_r2_ls_flags.test(R2FLAG_GLOBALMATERIAL))	mtl=ps_r2_gmaterial;
 #endif
+		if (!(T && T->m_is_hot))
+			RCache.hemi.set_hotness(0.f, 0.f, 0.f, 0.f);
+
 		RCache.hemi.set_material(o_hemi, o_sun, 0, (mtl < 5 ? (mtl + .5f) / 4.f : mtl));
 		RCache.hemi.set_pos_faces(o_hemi_cube[CROS_impl::CUBE_FACE_POS_X],
 		                          o_hemi_cube[CROS_impl::CUBE_FACE_POS_Y],
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
index 4280e5f..442d4ad 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget.cpp
@@ -350,6 +350,8 @@ CRenderTarget::CRenderTarget()
 	b_gasmask_drops = xr_new<CBlender_gasmask_drops>();
 	b_gasmask_dudv = xr_new<CBlender_gasmask_dudv>();
 	b_nightvision = xr_new<CBlender_nightvision>();
+	b_fakescope = xr_new<CBlender_fakescope>(); //crookr
+	b_heatvision = xr_new<CBlender_heatvision>(); //--DSR-- HeatVision
 	b_lut = xr_new<CBlender_lut>();
 	b_smaa = xr_new<CBlender_smaa>();
 
@@ -434,6 +436,13 @@ CRenderTarget::CRenderTarget()
 		rt_Generic_1.create(r2_RT_generic1, w, h, D3DFMT_A8R8G8B8, 1);
 		rt_Generic.create(r2_RT_generic, w, h, D3DFMT_A8R8G8B8, 1);
 
+
+		rt_fakescope.create(r2_RT_scopert, w, h, D3DFMT_A8R8G8B8, 1); //crookr fakescope
+
+		//--DSR-- HeatVision_start
+		rt_Heat.create(r2_RT_heat, w, h, D3DFMT_A8R8G8B8, SampleCount);
+		//--DSR-- HeatVision_end
+
         if (RImplementation.o.dx10_msaa)
             rt_Generic_temp.create("$user$generic_temp", w, h, D3DFMT_A8R8G8B8, SampleCount);
         else
@@ -479,6 +488,9 @@ CRenderTarget::CRenderTarget()
 	s_gasmask_drops.create(b_gasmask_drops, "r2\\gasmask_drops");
 	s_gasmask_dudv.create(b_gasmask_dudv, "r2\\gasmask_dudv");
 	s_nightvision.create(b_nightvision, "r2\\nightvision");
+
+	s_fakescope.create(b_fakescope, "r2\\fakescope"); //crookr
+	s_heatvision.create(b_heatvision, "r2\\heatvision"); //--DSR-- HeatVision
 	s_lut.create(b_lut, "r2\\lut");	
 	// OCCLUSION
 	s_occq.create(b_occq, "r2\\occq");
@@ -1156,6 +1168,8 @@ CRenderTarget::~CRenderTarget()
 	xr_delete(b_gasmask_drops);
 	xr_delete(b_gasmask_dudv);
 	xr_delete(b_nightvision);
+	xr_delete(b_fakescope); //crookr
+	xr_delete(b_heatvision); //--DSR-- HeatVision
 	xr_delete(b_lut);	
 	xr_delete(b_smaa);
 
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget.h b/src/Layers/xrRenderPC_R4/r4_rendertarget.h
index 37da92e..846ab97 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget.h
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget.h
@@ -58,6 +58,8 @@ public:
 	IBlender* b_gasmask_drops;
 	IBlender* b_gasmask_dudv;
 	IBlender* b_nightvision;
+	IBlender* b_fakescope; //crookr
+	IBlender* b_heatvision; //--DSR-- HeatVision
 	IBlender* b_lut;
 	IBlender* b_smaa;
 	// compute shader for hdao
@@ -83,6 +85,10 @@ public:
 	ref_rt rt_Position; // 64bit,	fat	(x,y,z,?)				(eye-space)
 	ref_rt rt_Color; // 64/32bit,fat	(r,g,b,specular-gloss)	(or decompressed MET-8-8-8-8)
 
+	//--DSR-- HeatVision_start
+	ref_rt rt_Heat;
+	//--DSR-- HeatVision_end
+
 	// 
 	ref_rt rt_Accumulator; // 64bit		(r,g,b,specular)
 	ref_rt rt_Accumulator_temp; // only for HW which doesn't feature fp16 blend
@@ -95,6 +101,9 @@ public:
 	
 	ref_rt rt_secondVP;	// 32bit		(r,g,b,a) --//#SM+#-- +SecondVP+
 
+
+	ref_rt rt_fakescope;	// crookr fakescope
+
 	ref_rt rt_dof;
 	ref_rt rt_ui_pda;
 	
@@ -174,7 +183,9 @@ private:
 	ref_shader s_pp_bloom;	
 	ref_shader s_gasmask_drops;
 	ref_shader s_gasmask_dudv;
-	ref_shader s_nightvision;	
+	ref_shader s_nightvision;
+	ref_shader s_fakescope; //crookr
+	ref_shader s_heatvision; //--DSR-- HeatVision
 	ref_shader s_smaa;
 
 	ref_shader s_lut;
@@ -300,6 +311,8 @@ public:
 	void phase_gasmask_drops();
 	void phase_gasmask_dudv();
 	void phase_nightvision();
+	void phase_fakescope(); //crookr
+	void phase_heatvision(); //--DSR-- HeatVision
 	void phase_lut();		
 	void phase_smaa();
 	void phase_scene_prepare();
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
index 875ae48..9a58b03 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_combine.cpp
@@ -290,10 +290,14 @@ void CRenderTarget::phase_combine()
 	// Forward rendering
 	{
 		PIX_EVENT(Forward_rendering);
+
+		//--DSR-- HeatVision_start
 		if (!RImplementation.o.dx10_msaa)
-			u_setrt(rt_Generic_0, 0, 0, HW.pBaseZB); // LDR RT
+			u_setrt(rt_Generic_0, rt_Heat, 0, HW.pBaseZB); // LDR RT
 		else
-			u_setrt(rt_Generic_0_r, 0, 0, RImplementation.Target->rt_MSAADepth->pZRT); // LDR RT
+			u_setrt(rt_Generic_0_r, rt_Heat, 0, RImplementation.Target->rt_MSAADepth->pZRT); // LDR RT
+		//--DSR-- HeatVision_end
+
 		RCache.set_CullMode(CULL_CCW);
 		RCache.set_Stencil(FALSE);
 		RCache.set_ColorWriteEnable();
@@ -396,6 +400,16 @@ void CRenderTarget::phase_combine()
 	if(ps_r2_nightvision > 0)
 		phase_nightvision();
 	
+	//--DSR-- HeatVision_start
+	if (ps_r2_heatvision > 0)
+		phase_heatvision();
+	//--DSR-- HeatVision_end
+
+	if (scope_fake_enabled)
+	{
+		phase_fakescope(); //crookr
+	}
+
     //SMAA
 	if (ps_smaa_quality)
 	{
diff --git a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_scene.cpp b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_scene.cpp
index 0b59b29..071894b 100644
--- a/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_scene.cpp
+++ b/src/Layers/xrRenderPC_R4/r4_rendertarget_phase_scene.cpp
@@ -14,6 +14,10 @@ void CRenderTarget::phase_scene_prepare()
 		FLOAT ColorRGBA[4] = {0.0f, 0.0f, 0.0f, 0.0f};
 		HW.pContext->ClearRenderTargetView(rt_Position->pRT, ColorRGBA);
 
+		//--DSR-- HeatVision_start
+		HW.pContext->ClearRenderTargetView(rt_Heat->pRT, ColorRGBA);
+		//--DSR-- HeatVision_end
+
 		if (!RImplementation.o.dx10_msaa)
 			HW.pContext->ClearDepthStencilView(HW.pBaseZB, D3D_CLEAR_DEPTH | D3D_CLEAR_STENCIL, 1.0f, 0);
 		else
@@ -39,8 +43,10 @@ void CRenderTarget::phase_scene_begin()
 
 	// Targets, use accumulator for temporary storage
 	{
-		if (RImplementation.o.albedo_wo) u_setrt(rt_Position, rt_Accumulator, pZB);
-		else u_setrt(rt_Position, rt_Color, pZB);
+		//--DSR-- HeatVision_start
+		if (RImplementation.o.albedo_wo) u_setrt(rt_Position, rt_Accumulator, rt_Heat, pZB);
+		else u_setrt(rt_Position, rt_Color, rt_Heat, pZB);
+		//--DSR-- HeatVision_end
 	}
 
 
diff --git a/src/xrEngine/IRenderable.h b/src/xrEngine/IRenderable.h
index 040868a..b7c60d3 100644
--- a/src/xrEngine/IRenderable.h
+++ b/src/xrEngine/IRenderable.h
@@ -24,6 +24,11 @@ public:
 	virtual void renderable_Render() = 0;
 	virtual BOOL renderable_ShadowGenerate() { return FALSE; };
 	virtual BOOL renderable_ShadowReceive() { return FALSE; };
+
+	//--DSR-- HeatVision_start
+	virtual float GetHotness() { return 0.0; }
+	virtual float GetTransparency() { return 0.0; }
+	//--DSR-- HeatVision_end
 };
 
 #endif // IRENDERABLE_H_INCLUDED
diff --git a/src/xrEngine/xr_ioc_cmd.cpp b/src/xrEngine/xr_ioc_cmd.cpp
index a1ec515..4aa560a 100644
--- a/src/xrEngine/xr_ioc_cmd.cpp
+++ b/src/xrEngine/xr_ioc_cmd.cpp
@@ -596,6 +596,21 @@ public:
 	}
 };
 
+extern void updateCurrentScope();
+class CCC_ScopeFactor : public CCC_Float
+{
+public:
+	CCC_ScopeFactor(LPCSTR N, float* V) : CCC_Float(N, V, 0.01f, 1.0f)
+	{
+	}
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Float::Execute(args);
+		updateCurrentScope();
+	}
+};
+
 //-----------------------------------------------------------------------
 /*
 #ifdef DEBUG
@@ -864,6 +879,22 @@ Ivector4 g_crosshair_color_temp;
 float g_freelook_z_offset;
 float g_ironsights_factor = 1.25f;
 
+// crookr fake scope params (sorry)
+float scope_fog_interp = 0.15f;
+float scope_fog_travel = 0.25f;
+float scope_fog_attack = 0.66f;
+float scope_fog_mattack = 0.25f;
+//float scope_drift_amount = 1.f;
+float scope_ca = 0.003f;
+float scope_outerblur = 1.0f;
+float scope_innerblur = 0.1f;
+float scope_scrollpower = 0.66f;
+float scope_brightness = 1.0f;
+float scope_radius = 0.f;
+float scope_fog_radius = 1.25f;
+float scope_fog_sharp = 4.0f;
+int scope_2dtexactive = 0.0;
+
 void CCC_Register()
 {
 	// General
@@ -1024,6 +1055,24 @@ void CCC_Register()
 
 	CMD4(CCC_Float, "g_ironsights_zoom_factor", &g_ironsights_factor, 1.f, 2.f);
 	
+	// - CrookR
+	CMD2(CCC_Float, "scope_blur_outer", &scope_outerblur);
+	CMD2(CCC_Float, "scope_blur_inner", &scope_innerblur);
+	CMD2(CCC_ScopeFactor, "scope_factor", &scope_scrollpower);
+	CMD2(CCC_Float, "scope_brightness", &scope_brightness);
+
+	CMD2(CCC_Float, "scope_fog_interp", &scope_fog_interp);
+	CMD4(CCC_Float, "scope_fog_travel", &scope_fog_travel, 0.f, 5.f);
+	CMD4(CCC_Float, "scope_fog_swayAim", &scope_fog_attack, -999.f, 999.f);
+	CMD4(CCC_Float, "scope_fog_swayMove", &scope_fog_mattack, -999.f, 999.f);
+	//CMD4(CCC_Float, "scope_drift_amount", &scope_drift_amount, -999.f, 999.f);
+
+	CMD2(CCC_Float, "scope_ca", &scope_ca);
+	CMD4(CCC_Float, "scope_radius", &scope_radius, 0, 2);
+	CMD4(CCC_Float, "scope_fog_radius", &scope_fog_radius, 0, 1000);
+	CMD4(CCC_Float, "scope_fog_sharp", &scope_fog_sharp, 0, 1000);
+	CMD2(CCC_Integer, "scope_2dtexactive", &scope_2dtexactive);
+
 #ifdef DEBUG
     extern BOOL debug_destroy;
     CMD4(CCC_Integer, "debug_destroy", &debug_destroy, FALSE, TRUE);
diff --git a/src/xrGame/ActorInput.cpp b/src/xrGame/ActorInput.cpp
index 8499334..48becf2 100644
--- a/src/xrGame/ActorInput.cpp
+++ b/src/xrGame/ActorInput.cpp
@@ -433,7 +433,7 @@ void CActor::IR_OnMouseMove(int dx, int dy)
 	float LookFactor = GetLookFactor();
 
 	CCameraBase* C = cameras[cam_active];
-	float scale = (C->f_fov / g_fov) * psMouseSens * psMouseSensScale / 50.f / LookFactor;
+    float scale = (C->f_fov / g_fov) * (psMouseSens * sens_multiple) * psMouseSensScale / 50.f / LookFactor;
 	if (dx)
 	{
 		float d = float(dx) * scale;
diff --git a/src/xrGame/Entity.cpp b/src/xrGame/Entity.cpp
index 70a5767..11b4e80 100644
--- a/src/xrGame/Entity.cpp
+++ b/src/xrGame/Entity.cpp
@@ -401,3 +401,24 @@ void CEntity::ChangeTeam(int team, int squad, int group)
 	Level().seniority_holder().team(g_Team()).squad(g_Squad()).group(g_Group()).register_member(this);
 	on_after_change_team();
 }
+
+//--DSR-- HeatVision_start
+u32 clampU(u32 x, u32 a, u32 b) {
+	if (x < a) return a;
+	else if (x > b) return b;
+	return x;
+}
+
+float CEntity::GetHotness() {
+	if (AlreadyDie() || !g_Alive())
+		return 1.0f - (float)clampU(Device.dwTimeGlobal - m_level_death_time, 0, 20000) / 20000.0f;
+	return 1.0f;
+}
+
+void CEntity::OnChangeVisual()
+{
+	inherited::OnChangeVisual();
+	if (renderable.visual != 0)
+		renderable.visual->MarkAsHot(true);
+}
+//--DSR-- HeatVision_end
diff --git a/src/xrGame/Entity.h b/src/xrGame/Entity.h
index c5697ab..b21f2ec 100644
--- a/src/xrGame/Entity.h
+++ b/src/xrGame/Entity.h
@@ -82,6 +82,11 @@ public:
 	/*	virtual*/
 	IC void SetMaxHealth(float v) { m_entity_condition->max_health() = v; }
 
+	//--DSR-- HeatVision_start
+	virtual float GetHotness();
+	virtual void  OnChangeVisual();
+	//--DSR-- HeatVision_end
+
 	/*virtual*/
 	IC BOOL g_Alive() const { return GetfHealth() > 0; }
 	virtual BOOL g_State(SEntityState&) const { return FALSE; }
diff --git a/src/xrGame/NewZoomFlag.h b/src/xrGame/NewZoomFlag.h
new file mode 100644
index 0000000..ec29839
--- /dev/null
+++ b/src/xrGame/NewZoomFlag.h
@@ -0,0 +1,13 @@
+#pragma once
+//New_zoom
+enum
+{
+	NEW_ZOOM = (1 << 0),
+	SDS_ZOOM = (1 << 1),
+	SDS_SPEED = (1 << 3),
+	SDS = (1 << 4),
+
+};
+
+extern Flags32 zoomFlags;
+//
\ No newline at end of file
diff --git a/src/xrGame/Weapon.cpp b/src/xrGame/Weapon.cpp
index 080f84d..d8665de 100644
--- a/src/xrGame/Weapon.cpp
+++ b/src/xrGame/Weapon.cpp
@@ -42,6 +42,47 @@
 float f_weapon_deterioration = 1.0f;
 extern CUIXml* pWpnScopeXml;
 
+//////////
+extern float scope_radius;
+
+Flags32 zoomFlags = {};
+extern float n_zoom_step_count;
+float sens_multiple = 1.0f;
+
+
+float CWeapon::SDS_Radius(bool alt) {
+	shared_str scope_tex_name;
+	if (m_zoomtype == 0 && zoomFlags.test(SDS))
+	{
+		if (0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+		{
+			scope_tex_name = pSettings->r_string(GetScopeName(), alt ? "scope_texture_alt" : "scope_texture");
+		}
+		else
+		{
+			scope_tex_name = READ_IF_EXISTS(pSettings, r_string, cNameSect(), alt ? "scope_texture_alt" : "scope_texture", NULL);
+		}
+
+		if (scope_tex_name != 0) {
+			auto item = listScopeRadii.find(scope_tex_name);
+			if (item != listScopeRadii.end()) {
+				return item->second;
+			}
+			else {
+				return 0.0;
+			}
+		}
+		else {
+			return 0.0;
+		}
+	}
+	else {
+		return 0.0;
+	}
+}
+
+//////////
+
 CWeapon::CWeapon()
 {
 	SetState(eHidden);
@@ -103,6 +144,7 @@ CWeapon::CWeapon()
 	//PP.RQ.set(NULL, 0.f, -1);
 }
 
+extern int scope_2dtexactive; //crookr
 CWeapon::~CWeapon()
 {
 	xr_delete(m_UIScope);
@@ -218,8 +260,32 @@ void CWeapon::UpdateFireDependencies_internal()
 	}
 }
 
-void CWeapon::UpdateUIScope()
-{
+void updateCurrentScope() {
+	if (!g_pGameLevel) return;
+
+	CInventoryOwner* pGameObject = smart_cast<CInventoryOwner*>(Level().Objects.net_Find(0));
+	if (pGameObject) {
+		if (pGameObject->inventory().ActiveItem()) {
+			CWeapon* weapon = smart_cast<CWeapon*>(pGameObject->inventory().ActiveItem());
+			if (weapon) {
+				weapon->UpdateZoomParams();
+			}
+		}
+	}
+}
+
+void CWeapon::UpdateZoomParams() {
+	//////////
+	m_zoom_params.m_fMinBaseZoomFactor = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "min_scope_zoom_factor", 200.0f);
+
+
+	float zoom_multiple = 1.0f;
+	if (zoomFlags.test(SDS_ZOOM) && (SDS_Radius() > 0.0)) {
+		zoom_multiple = scope_scrollpower;
+	}
+
+	//////////
+
 	// Load scopes.xml if it's not loaded
 	if (pWpnScopeXml == nullptr)
 	{
@@ -230,30 +296,47 @@ void CWeapon::UpdateUIScope()
 	// update zoom factor
 	if (m_zoomtype == 2) //GL
 	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_GL || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_gl", false);
 		m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[1] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "gl_zoom_factor", 0);
-	}
-	else if (m_zoomtype == 1) //Alt
+	} else if (m_zoomtype == 1) //Alt
 	{
-		m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[2] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "scope_zoom_factor_alt", 0);
-	}
-	else //Main Sight
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Alt || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_alt", false);
+		m_zoom_params.m_fScopeZoomFactor = (g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[2] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "scope_zoom_factor_alt", 0)) / (READ_IF_EXISTS(pSettings, r_string, cNameSect(), "scope_texture_alt", NULL) && zoomFlags.test(SDS_ZOOM) && (SDS_Radius(true) > 0.0) ? zoom_multiple : 1);
+	} else //Main Sight
 	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Primary || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom", false);
 		if (g_player_hud->m_adjust_mode)
 		{
-			m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_zoom_factor[0];
-		}
-		else if (ALife::eAddonPermanent != m_eScopeStatus && 0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+			m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_zoom_factor[0] / zoom_multiple;
+		} else if (ALife::eAddonPermanent != m_eScopeStatus && 0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
 		{
-			m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(GetScopeName(), "scope_zoom_factor");
-		}
-		else
+			m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(GetScopeName(), "scope_zoom_factor") / zoom_multiple;
+		} else
 		{
-			m_zoom_params.m_fScopeZoomFactor = m_zoom_params.m_fBaseZoomFactor;
+			m_zoom_params.m_fScopeZoomFactor = m_zoom_params.m_fBaseZoomFactor / zoom_multiple;
 		}
 	}
 
-	if (IsZoomed())
-		m_zoom_params.m_fCurrentZoomFactor = m_zoom_params.m_fScopeZoomFactor;
+	if (IsZoomed()) {
+		scope_radius = SDS_Radius();
+		if (m_zoomtype == 0 && zoomFlags.test(SDS_SPEED) && (scope_radius > 0.0)) {
+			sens_multiple = scope_scrollpower;
+		} else {
+			sens_multiple = 1.0f;
+		}
+
+
+		if (m_zoom_params.m_bUseDynamicZoom) {
+			SetZoomFactor(m_fRTZoomFactor / zoom_multiple);
+		} else {
+			SetZoomFactor(m_zoom_params.m_fScopeZoomFactor);
+		}
+	}
+}
+
+void CWeapon::UpdateUIScope()
+{
+	UpdateZoomParams();
 
 	// Change or remove scope texture
 	shared_str scope_tex_name;
@@ -276,6 +359,7 @@ void CWeapon::UpdateUIScope()
 	if (!g_dedicated_server)
 	{
 		xr_delete(m_UIScope);
+		scope_2dtexactive = 0; //crookr
 
 		if (!scope_tex_name || scope_tex_name.equal("none") || g_player_hud->m_adjust_mode)
 			return;
@@ -290,6 +374,7 @@ void CWeapon::SwitchZoomType()
 	if (m_zoomtype == 0 && (m_altAimPos || g_player_hud->m_adjust_mode))
 	{
 		m_zoomtype = 1;
+        m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Alt || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_alt", false);
 	}
 	else if (IsGrenadeLauncherAttached())
 	{
@@ -299,6 +384,7 @@ void CWeapon::SwitchZoomType()
 	else if (m_zoomtype != 0)
 	{
 		m_zoomtype = 0;
+        m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Primary || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom", false);
 	}
 
 	UpdateUIScope();
@@ -1616,11 +1702,22 @@ float CWeapon::CurrentZoomFactor()
 
 void CWeapon::OnZoomIn()
 {
+    //////////
+    scope_radius = SDS_Radius();
+
+	if ((scope_radius > 0.0) && zoomFlags.test(SDS_SPEED)) {
+		sens_multiple = scope_scrollpower;
+	}
+	else {
+		sens_multiple = 1.0f;
+	}
+    //////////
+    
 	m_zoom_params.m_bIsZoomModeNow = true;
 	if (m_zoom_params.m_bUseDynamicZoom)
-		SetZoomFactor(m_fRTZoomFactor);
+		SetZoomFactor(scope_radius > 0.0 ? m_fRTZoomFactor / scope_scrollpower : m_fRTZoomFactor);
 	else
-		m_zoom_params.m_fCurrentZoomFactor = CurrentZoomFactor();
+		SetZoomFactor(CurrentZoomFactor());
 
 	if (m_zoom_params.m_bZoomDofEnabled && !IsScopeAttached())
 		GamePersistent().SetEffectorDOF(m_zoom_params.m_ZoomDof);
@@ -1650,7 +1747,11 @@ void CWeapon::OnZoomIn()
 void CWeapon::OnZoomOut()
 {
 	m_zoom_params.m_bIsZoomModeNow = false;
-	m_fRTZoomFactor = GetZoomFactor(); //store current
+    if (m_zoom_params.m_bUseDynamicZoom)
+    {
+        m_fRTZoomFactor = scope_radius > 0.0 ? GetZoomFactor() * scope_scrollpower : GetZoomFactor(); //store current
+    }
+    
 	m_zoom_params.m_fCurrentZoomFactor = g_fov;
 
 	GamePersistent().RestoreEffectorDOF();
@@ -1668,6 +1769,11 @@ void CWeapon::OnZoomOut()
 	}
 
 	g_player_hud->updateMovementLayerState();
+    
+    scope_radius = 0.0;
+    scope_2dtexactive = 0;
+    sens_multiple = 1.0f;
+
 }
 
 CUIWindow* CWeapon::ZoomTexture()
@@ -1675,7 +1781,10 @@ CUIWindow* CWeapon::ZoomTexture()
 	if (UseScopeTexture())
 		return m_UIScope;
 	else
+	{
+		scope_2dtexactive = 0; //crookr
 		return NULL;
+	}
 }
 
 void CWeapon::SwitchState(u32 S)
@@ -2516,6 +2625,9 @@ void CWeapon::render_item_ui()
 
 	ZoomTexture()->Update();
 	ZoomTexture()->Draw();
+
+	//crookr
+	scope_2dtexactive = ZoomTexture()->IsShown() ? 1 : 0;
 }
 
 bool CWeapon::unlimited_ammo()
@@ -2697,16 +2809,46 @@ bool CWeapon::IsHudModeNow()
 	return (HudItemData() != NULL);
 }
 
+void NewGetZoomData(const float scope_factor, float& delta, float& min_zoom_factor, float zoom, float min_zoom)
+{
+	
+	float def_fov = float(g_fov);
+	float min_zoom_k = 0.3f;
+	float delta_factor_total = def_fov - scope_factor;
+	VERIFY(delta_factor_total > 0);
+	float loc_min_zoom_factor = ((atan(tan(def_fov * (0.5 * PI / 180)) / g_ironsights_factor) / (0.5 * PI / 180)) / 0.75f) * (scope_radius > 0.0 ? scope_scrollpower : 1);
+
+	//Msg("min zoom factor %f, min zoom %f, loc min zoom factor %f", min_zoom_factor, min_zoom, loc_min_zoom_factor);
+
+	if (min_zoom < loc_min_zoom_factor) {
+		min_zoom_factor = min_zoom;
+	}
+	else {
+		min_zoom_factor = loc_min_zoom_factor;
+	}
+
+	delta = ((delta_factor_total * (1 - min_zoom_k)) / n_zoom_step_count) * (zoom / def_fov);
+}
+
 void CWeapon::ZoomInc()
 {
 	if (!IsScopeAttached()) return;
 	if (!m_zoom_params.m_bUseDynamicZoom) return;
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
-
-	float f = GetZoomFactor() - delta;
-	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
-	SetZoomFactor(f);
+	float power = scope_radius > 0.0 ? scope_scrollpower : 1;
+	//
+	if (zoomFlags.test(NEW_ZOOM)) {
+		NewGetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor, GetZoomFactor() * power, m_zoom_params.m_fMinBaseZoomFactor);
+	}
+	else {
+        GetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor);
+	}
+	//
+	float f = GetZoomFactor() * power - delta;
+	clamp(f, m_zoom_params.m_fScopeZoomFactor * power, min_zoom_factor);
+	SetZoomFactor(f / power);
+	//
+	m_fRTZoomFactor = GetZoomFactor() * power;
 }
 
 void CWeapon::ZoomDec()
@@ -2714,11 +2856,20 @@ void CWeapon::ZoomDec()
 	if (!IsScopeAttached()) return;
 	if (!m_zoom_params.m_bUseDynamicZoom) return;
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
-
-	float f = GetZoomFactor() + delta;
-	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
-	SetZoomFactor(f);
+	float power = scope_radius > 0.0 ? scope_scrollpower : 1;
+	//
+	if (zoomFlags.test(NEW_ZOOM)) {
+		NewGetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor, GetZoomFactor() * power, m_zoom_params.m_fMinBaseZoomFactor);
+	}
+	else {
+        GetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor);
+	}
+	//
+	float f = GetZoomFactor() * power + delta;
+	clamp(f, m_zoom_params.m_fScopeZoomFactor * power, min_zoom_factor);
+	SetZoomFactor(f / power);
+	//
+	m_fRTZoomFactor = GetZoomFactor() * power;
 }
 
 u32 CWeapon::Cost() const
diff --git a/src/xrGame/Weapon.h b/src/xrGame/Weapon.h
index 9880065..dc01e6b 100644
--- a/src/xrGame/Weapon.h
+++ b/src/xrGame/Weapon.h
@@ -14,6 +14,8 @@
 
 #include "CameraRecoil.h"
 
+#include "NewZoomFlag.h"
+
 class CEntity;
 class ENGINE_API CMotionDef;
 class CSE_ALifeItemWeapon;
@@ -26,6 +28,11 @@ class CNightVisionEffector;
 
 extern float f_weapon_deterioration;
 
+extern std::map<shared_str, float> listScopeRadii;
+
+extern float scope_scrollpower;
+extern float sens_multiple;
+
 struct PickParam
 {
 	collide::rq_result RQ;
@@ -317,6 +324,7 @@ protected:
 
 	struct SZoomParams
 	{
+        float m_fMinBaseZoomFactor;
 		bool m_bZoomEnabled;
 		bool m_bHideCrosshairInZoom;
 		bool m_bZoomDofEnabled;
@@ -331,6 +339,9 @@ protected:
 		Fvector4 m_ReloadDof;
 		Fvector4 m_ReloadEmptyDof; //Swartz: reload when empty mag. DOF
 		BOOL m_bUseDynamicZoom;
+		BOOL m_bUseDynamicZoom_Primary;
+		BOOL m_bUseDynamicZoom_Alt;
+		BOOL m_bUseDynamicZoom_GL;
 		shared_str m_sUseZoomPostprocess;
 		shared_str m_sUseBinocularVision;
 		CBinocularsVision* m_pVision;
@@ -452,6 +463,7 @@ public:
 	//virtual collide::rq_result& GetRQ() { return PP.RQ; }
 	//virtual void net_Relcase(CObject* object);
 	Fmatrix m_shoot_shake_mat;
+	void UpdateZoomParams();
 
 protected:
 	virtual void UpdateFireDependencies_internal();
@@ -878,4 +890,6 @@ public:
 	{
 		return cNameSect();
 	};
+    
+    float SDS_Radius(bool alt = false);
 };
diff --git a/src/xrGame/WeaponBinoculars.cpp b/src/xrGame/WeaponBinoculars.cpp
index 21be7d1..768462e 100644
--- a/src/xrGame/WeaponBinoculars.cpp
+++ b/src/xrGame/WeaponBinoculars.cpp
@@ -9,6 +9,9 @@
 #include "object_broker.h"
 #include "inventory.h"
 
+extern float n_zoom_step_count;
+float czoom;
+
 CWeaponBinoculars::CWeaponBinoculars()
 {
 	m_binoc_vision = NULL;
@@ -56,6 +59,7 @@ void CWeaponBinoculars::OnZoomIn()
 		}
 	}
 	inherited::OnZoomIn();
+    SetZoomFactor(czoom);
 }
 
 void CWeaponBinoculars::OnZoomOut()
@@ -75,6 +79,7 @@ void CWeaponBinoculars::OnZoomOut()
 
 BOOL CWeaponBinoculars::net_Spawn(CSE_Abstract* DC)
 {
+    czoom = CWeaponBinoculars::m_zoom_params.m_fScopeZoomFactor;
 	return inherited::net_Spawn(DC);
 }
 
@@ -115,24 +120,36 @@ void GetZoomData(const float scope_factor, float& delta, float& min_zoom_factor)
 	delta = (delta_factor_total * (1 - min_zoom_k)) / zoom_step_count;
 }
 
+void newGetZoomData(const float scope_factor, float& delta, float& min_zoom_factor, float c_zoom)
+{
+    float def_fov = float(g_fov);
+    float min_zoom_k = 0.3f;
+    float delta_factor_total = def_fov - scope_factor;
+    VERIFY(delta_factor_total > 0);
+    min_zoom_factor = def_fov - delta_factor_total * min_zoom_k;
+    delta = (delta_factor_total * (1 - min_zoom_k)) / n_zoom_step_count * (c_zoom / def_fov);
+}
+
 void CWeaponBinoculars::ZoomInc()
 {
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
+    newGetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor, czoom);
 
 	float f = GetZoomFactor() - delta;
 	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
 	SetZoomFactor(f);
+    czoom = f;
 }
 
 void CWeaponBinoculars::ZoomDec()
 {
 	float delta, min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
+    newGetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor, czoom);
 
 	float f = GetZoomFactor() + delta;
 	clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
 	SetZoomFactor(f);
+    czoom = f;
 }
 
 void CWeaponBinoculars::save(NET_Packet& output_packet)
diff --git a/src/xrGame/WeaponMagazined.cpp b/src/xrGame/WeaponMagazined.cpp
index b933f2a..6c97431 100644
--- a/src/xrGame/WeaponMagazined.cpp
+++ b/src/xrGame/WeaponMagazined.cpp
@@ -1316,6 +1316,7 @@ bool CWeaponMagazined::Detach(const char* item_section_name, bool b_spawn_item)
 		return inherited::Detach(item_section_name, b_spawn_item);;
 }
 
+extern int scope_2dtexactive; //crookr
 void CWeaponMagazined::InitAddons()
 {
 	if (IsScopeAttached())
@@ -1332,6 +1333,7 @@ void CWeaponMagazined::InitAddons()
 			if (m_UIScope)
 			{
 				xr_delete(m_UIScope);
+				scope_2dtexactive = 0;//crookr
 			}
 
 			if (!g_dedicated_server && scope_tex_name != NULL)
@@ -1348,6 +1350,7 @@ void CWeaponMagazined::InitAddons()
 		if (m_eScopeStatus != ALife::eAddonPermanent && m_UIScope)
 		{
 			xr_delete(m_UIScope);
+			scope_2dtexactive = 0;//crookr
 		}
 		ResetScopeKoeffs();
 	}
diff --git a/src/xrGame/WeaponUpgrade.cpp b/src/xrGame/WeaponUpgrade.cpp
index 4b266c9..27af437 100644
--- a/src/xrGame/WeaponUpgrade.cpp
+++ b/src/xrGame/WeaponUpgrade.cpp
@@ -281,6 +281,10 @@ bool CWeapon::install_upgrade_addon(LPCSTR section, bool test)
 	result |= process_if_exists_set(section, "scope_alive_detector", &CInifile::r_string_wb,
 	                                m_zoom_params.m_sUseBinocularVision, test);
 
+	process_if_exists_set(section, "scope_dynamic_zoom", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_Primary, test);
+	process_if_exists_set(section, "scope_dynamic_zoom_alt", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_Alt, test);
+	process_if_exists_set(section, "scope_dynamic_zoom_gl", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_GL, test);
+
 	result |= result2;
 
 	temp_int = (int)m_eSilencerStatus;
diff --git a/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp b/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp
index 2379645..dcb0f6e 100644
--- a/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp
+++ b/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp
@@ -505,6 +505,21 @@ CAI_Bloodsucker::visibility_t CAI_Bloodsucker::get_visibility_state() const
 	return m_force_visibility_state != unset ? m_force_visibility_state : m_visibility_state;
 }
 
+//--DSR-- HeatVision_start
+float CAI_Bloodsucker::GetTransparency() 
+{
+	if (m_visibility_state == no_visibility) 
+	{
+		return 1.0f;
+	}
+	else
+	{
+		return 0.0f;
+	}
+
+}
+//--DSR-- HeatVision_end
+
 void CAI_Bloodsucker::set_visibility_state(visibility_t new_state)
 {
 	if (m_force_visibility_state != unset)
@@ -540,6 +555,12 @@ void CAI_Bloodsucker::set_visibility_state(visibility_t new_state)
 	{
 		start_invisible_predator();
 	}
+	//--DSR-- HeatVision_start
+	/*else if (m_visibility_state == no_visibility)
+	{
+		start_invisible_predator();
+	}*/
+	//--DSR-- HeatVision_end
 	else
 	{
 		sound().play(CAI_Bloodsucker::eChangeVisibility);
@@ -856,12 +877,20 @@ void CAI_Bloodsucker::manual_deactivate()
 	setVisible(TRUE);
 }
 
+
+extern int ps_r2_heatvision;
 void CAI_Bloodsucker::renderable_Render()
 {
-	if (m_visibility_state != no_visibility)
-	{
+	//--DSR-- HeatVision_start
+	
+	//if (m_visibility_state != no_visibility)
+	//{
+	//	inherited::renderable_Render();  
+	//}
+
+	if (m_visibility_state != no_visibility || ps_r2_heatvision > 0)
 		inherited::renderable_Render();
-	}
+	//--DSR-- HeatVision_end
 }
 
 bool CAI_Bloodsucker::done_enough_hits_before_vampire()
diff --git a/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h b/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h
index 7fa710b..cffb4ae 100644
--- a/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h
+++ b/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h
@@ -215,6 +215,9 @@ private:
 	TTime m_runaway_invisible_time;
 
 public:
+
+	virtual float GetTransparency(); //--DSR-- HeatVision
+
 	float get_full_visibility_radius();
 	float get_partial_visibility_radius();
 	float get_no_visibility_radius();
diff --git a/src/xrGame/console_commands.cpp b/src/xrGame/console_commands.cpp
index 2841970..ff9c11a 100644
--- a/src/xrGame/console_commands.cpp
+++ b/src/xrGame/console_commands.cpp
@@ -60,6 +60,9 @@
 
 #include "..\..\xrEngine\x_ray.h"
 
+#include "NewZoomFlag.h"
+float n_zoom_step_count = 3.0f;
+
 string_path g_last_saved_game;
 
 #ifdef DEBUG
@@ -2512,4 +2515,16 @@ void CCC_RegisterCommands()
 		CMD4(CCC_Float, "g_streff", &streff, -10.f, 10.f);
 	//No need for server commands in a singleplayer-only mod
 	//register_mp_console_commands();
+    
+    zoomFlags.set(NEW_ZOOM, FALSE);
+    zoomFlags.set(SDS_ZOOM, TRUE);
+    zoomFlags.set(SDS_SPEED, TRUE);
+    zoomFlags.set(SDS, TRUE);
+
+    CMD3(CCC_Mask, "new_zoom_enable", &zoomFlags, NEW_ZOOM);
+    CMD3(CCC_Mask, "sds_zoom_enable", &zoomFlags, SDS_ZOOM);
+    CMD3(CCC_Mask, "sds_speed_enable", &zoomFlags, SDS_SPEED);
+    CMD3(CCC_Mask, "sds_enable", &zoomFlags, SDS);
+
+    CMD4(CCC_Float, "zoom_step_count", &n_zoom_step_count, 1.0f, 10.0f);
 }
diff --git a/src/xrGame/new_sds.h b/src/xrGame/new_sds.h
new file mode 100644
index 0000000..229a8a3
--- /dev/null
+++ b/src/xrGame/new_sds.h
@@ -0,0 +1,6 @@
+#pragma once
+
+#include "map"
+#include "../xrCore/xrstring.h"
+
+std::map<shared_str, float> listScopeRadii;
\ No newline at end of file
diff --git a/src/xrGame/player_hud.cpp b/src/xrGame/player_hud.cpp
index 96fae36..fcf4941 100644
--- a/src/xrGame/player_hud.cpp
+++ b/src/xrGame/player_hud.cpp
@@ -682,6 +682,10 @@ void player_hud::load(const shared_str& player_hud_sect, bool force)
 	m_model_2->dcast_PKinematics()->CalculateBones_Invalidate();
 	m_model_2->dcast_PKinematics()->CalculateBones(TRUE);
 
+	//--DSR-- HeatVision_start
+	m_model->dcast_RenderVisual()->MarkAsHot(true);
+	m_model_2->dcast_RenderVisual()->MarkAsHot(true);
+	//--DSR-- HeatVision_end
 }
 
 void player_hud::load_script(LPCSTR section)
diff --git a/src/xrGame/xrGame.vcxproj b/src/xrGame/xrGame.vcxproj
index c8e93f0..728e067 100644
--- a/src/xrGame/xrGame.vcxproj
+++ b/src/xrGame/xrGame.vcxproj
@@ -1228,6 +1228,8 @@
     <ClInclude Include="mt_config.h" />
     <ClInclude Include="Needles.h" />
     <ClInclude Include="NET_Queue.h" />
+    <ClInclude Include="NewZoomFlag.h" />
+    <ClInclude Include="new_sds.h" />
     <ClInclude Include="NoGravityZone.h" />
     <ClInclude Include="object_actions.h" />
     <ClInclude Include="object_actions_inline.h" />
diff --git a/src/xrServerEntities/script_engine_script.cpp b/src/xrServerEntities/script_engine_script.cpp
index 7f1edef..2d23b21 100644
--- a/src/xrServerEntities/script_engine_script.cpp
+++ b/src/xrServerEntities/script_engine_script.cpp
@@ -10,9 +10,14 @@
 #include "script_engine.h"
 #include "ai_space.h"
 #include "script_debugger.h"
+#include "new_sds.h"
 
 using namespace luabind;
 
+void AddScope(LPCSTR key, float val) {
+    listScopeRadii[key] = val;
+}
+
 void LuaLog1(LPCSTR caMessage)
 {
 #ifndef MASTER_GOLD
@@ -240,6 +245,7 @@ void CScriptEngine::script_register(lua_State* L)
 		def("user_name", &user_name),
 		def("time_global", &script_time_global),
 		def("time_global_async", &script_time_global_async),
+        def("add_scope_radii", &AddScope),
 #ifdef XRGAME_EXPORTS
 		def("device", &get_device),
 		def("is_enough_address_space_available", &is_enough_address_space_available_impl),
